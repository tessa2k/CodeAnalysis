{
    "._plot_single_run_from_file.py": {
        "comments": [],
        "variables": [
            "dropbox",
            "B791",
            "ATTR",
            "X",
            "quarantine",
            "E0A56FA2",
            "apple",
            "e",
            "V",
            "attrs",
            "Mac",
            "OS",
            "q",
            "Safari",
            "com"
        ]
    },
    "._reseau_mitral_granule_fig_param_dic.py": {
        "comments": [],
        "variables": [
            "dropbox",
            "B791",
            "ATTR",
            "X",
            "quarantine",
            "E0A56FA2",
            "apple",
            "Mac",
            "e",
            "attrs",
            "U",
            "OS",
            "q",
            "Safari",
            "com"
        ]
    },
    "._oscillation_analysis.py": {
        "comments": [],
        "variables": [
            "dropbox",
            "B791",
            "ATTR",
            "X",
            "quarantine",
            "E0A56FA2",
            "apple",
            "e",
            "V",
            "attrs",
            "Mac",
            "OS",
            "q",
            "Safari",
            "com"
        ]
    },
    "._params_for_article_fig.py": {
        "comments": [],
        "variables": [
            "dropbox",
            "B791",
            "ATTR",
            "X",
            "quarantine",
            "E0A56FA2",
            "apple",
            "e",
            "V",
            "attrs",
            "Mac",
            "OS",
            "q",
            "Safari",
            "com"
        ]
    },
    "._plot_multi_run_from_file.py": {
        "comments": [],
        "variables": [
            "dropbox",
            "B791",
            "ATTR",
            "X",
            "quarantine",
            "E0A56FA2",
            "apple",
            "e",
            "V",
            "attrs",
            "Mac",
            "OS",
            "q",
            "Safari",
            "com"
        ]
    },
    "._readme.txt": {
        "comments": [
            "\u0000\u0005\u0016\u0007\u0000\u0002\u0000\u0000Mac OS X        \u0000\u0002\u0000\u0000\u0000\t\u0000\u0000\u00002\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0001\u000e\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ATTR\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u000e\u0000\u0000\u0000\u0000\u0000\u0000V\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000<\u0000\u0000\u0015com.apple.quarantine\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u001a\u0000\u0000\u0012com.dropbox.attrs\u0000\u0000\u0000\u0000q/0083;6048f032;Safari;E0A56FA2-53E9-4482-B791-5161D65A6DA1\u0000\n\u0012\n\u00103k\u001c)e\u0000\u0000\u0000\u0000\u0000\u00122\u001b\u0010\u073d\f",
            ""
        ],
        "variables": [
            "dropbox",
            "B791",
            "ATTR",
            "X",
            "quarantine",
            "E0A56FA2",
            "apple",
            "e",
            "V",
            "attrs",
            "Mac",
            "OS",
            "q",
            "Safari",
            "com"
        ]
    },
    "._model_mitral_clean.py": {
        "comments": [],
        "variables": [
            "dropbox",
            "B791",
            "ATTR",
            "X",
            "quarantine",
            "E0A56FA2",
            "apple",
            "e",
            "V",
            "attrs",
            "Mac",
            "OS",
            "q",
            "Safari",
            "com"
        ]
    },
    "._populationstatemonitor.py": {
        "comments": [],
        "variables": [
            "Sf",
            "K9rq",
            "pYl",
            "Mac",
            "uQG30",
            "h",
            "k",
            "F",
            "p",
            "jqlq",
            "n",
            "B4E235E4912A",
            "dropbox",
            "S",
            "ATTR",
            "l",
            "X",
            "G",
            "Fbc",
            "F953",
            "e",
            "apple",
            "_",
            "attrs",
            "B790",
            "OS",
            "Q",
            "d",
            "o",
            "DrC",
            "g",
            "M",
            "ZI",
            "y",
            "J",
            "Iy",
            "Mail",
            "quarantine",
            "cy8",
            "metadata",
            "W",
            "zV",
            "prz",
            "com",
            "kMDLabel_32dn2cta4wfibgarfd5xk5mi6a"
        ]
    },
    "._model_granule_clean.py": {
        "comments": [],
        "variables": [
            "dropbox",
            "B791",
            "ATTR",
            "X",
            "quarantine",
            "E0A56FA2",
            "apple",
            "e",
            "V",
            "attrs",
            "Mac",
            "OS",
            "q",
            "Safari",
            "com"
        ]
    },
    "reseau_mitral_granule_fig_param_dic.py": {
        "comments": [
            "# -*- coding: utf-8 -*-\n\"\"\"\nThis script contains the main fucntion to simulate the network and the associated dictionary of default parameters.\n\nThe \"main\" section provide a way to simulate and record \neither a single run with lot of details \nor multiple runs (with multiprocessing) with only LFPs\n\"\"\"\n\n#~ import brian_no_units\nfrom brian import *\n\nfrom numpy.random import seed\n\nfrom model_mitral_clean import *\nfrom model_granule_clean import *\nfrom populationstatemonitor import *\n\nfrom oscillation_analysis import beta_gamma_detection, spectrum_analysis\nfrom plot_single_run_from_file import single_LFP_analysis\nfrom plot_multi_run_from_file import multi_LFP_analysis,LFP_frequency_content\n\n\n# Dictionary of default parameters for simulations, used as a basis to generate dictionary of specific simulations\nparam_dict_default=dict(\n                        # General simulation params\n                        dt=0.05*ms,\n                        sim_time=4.*second,\n                        t_init_M=0.*ms, # time start of mitral sensory excitation (before, no input)\n                        t_init_G=0.*ms, # time start of granule centrifugal modulation (before, base input is used)\n                        \n                        # Mitral intrinsic and input params\n                        N_mitral = 100,\n                        num_activated_mitral=100, # introduction of this parameter simplify the random selection of activated mitral cells at each run\n                        M_gEinj= (linspace,(6.1,7.6,100),siemens*meter**-2), # (linspace(6.1,7.6,N_mitral))*siemens*meter**-2, # MC max sensory input conductances\n                        M_gEinj_shift=0., # Used only to test gamma for distinct average M_gEinj\n                        M_gEinj_base=None, # use None for no slow respiratory modulation of MC input, otherwise generally 4.0*siemens*meter**-2 \n                        M_taumKs = 7.*ms, \n                        M_tauI=7.*ms, # weak inh decay time\n                        M_tauI_G=7.*ms, # strong inh decay time\n                        M_gI_cst= 20.*siemens*meter**-2, # mitral constant inhibitory input\n                        recorded_mitrals=[10,20,30,40,50,60,70,80,90,99], # if return_details=True only !\n                        \n                        # Granule input params\n                        use_granule=False,\n                        N_granule=100,\n                        G_input='constant', # choose between \"constant\", \"ramp\", \"sinusoid\"\n                        G_I_base=-4.*nA, # before t_init or for \"constant\" input\n                        G_I_min=-4.*nA, # min of sinusoid\n                        G_I_max=-.1*nA, # max of sinusoid\n                        recorded_granules=[10,20,30,40,50,60,70,80,90,99], # if return_details=True only !\n                        \n                        # Respiratory rhythm parameters\n                        freq_modul=2.*Hz, \n                        MC_phase_dispersion=1.5, # SD of Gaussian distribution of phase shifts\n                        GC_phase_dispersion=0.2, # SD of Gaussian distribution of phase shifts\n                        GC_phase_shift=-pi/2, # Phase shift of granule centrifugal input vs mitral sensory input\n                        \n                        # Connectivity parameters\n                        weakinh_connectproba=1.,\n                        weakinh_weight=1.,\n                        weakinh_mean_delay=9.*ms, # final delays: uniform in the range \"mean +/- dispersion\"\n                        weakinh_delay_dispersion=4.*ms, # final delays: uniform in the range \"mean +/- dispersion\"\n                        stronginh_connectproba=0.5,\n                        stronginh_weight=1.,\n                        exc_weight=1., # Automatically multiplied by 2.5 if use_AMPA_STP is set to True\n                        use_AMPA_STP=False, # MC to GC short term plasticity (calibrated for a pure \"depression\")\n                        )\n\ndef reseau_mitral_granule(param_dict,return_details=True,report='text'):\n    \"\"\"\n    Main function to launch a single run of the network with a set of parameters given by param_dict\n    Check param_dict_default for the list of parameters and their roles\n    \n    If return_details is set to True, a result_dict is produced with many details recorded during the simulations,\n    otherwise only the LFP is returned\n    \n    \"report\" corresponds to the BRIAN \"brian.run\" function parameter\n    \"\"\"\n\n    # Clear Brian objects in memory\n    reinit_default_clock()\n    clear(True)\n    seed()\n\n    # Parameters\n    defaultclock.dt = param_dict['dt']\n    sim_time = param_dict['sim_time']\n    t_init_M = param_dict['t_init_M']\n    t_init_G = param_dict['t_init_G']\n    use_granule = param_dict['use_granule']\n    \n    # Mitral model and initialization\n    N_mitral= param_dict['N_mitral']\n    M = NeuronGroup(N_mitral, Mitral_eqs, threshold=-30*mV, reset=Mitral_reset,freeze=False,compile=True)\n    M.V=(-60.+rand(N_mitral)*15.)*mV\n    M.W=0.1*(1.+0.5*rand(N_mitral))\n    M.X=0.3*(1.+0.5*rand(N_mitral))\n    M.Y=0.\n    func_name,func_param,func_unit=param_dict['M_gEinj']\n    M.gEinj= func_name(*func_param)*func_unit+param_dict['M_gEinj_shift']*func_unit\n    \n    if param_dict['num_activated_mitral']<N_mitral:\n        # Randomly put to 0 the activation of N_mitral-param_dict['num_activated_mitral']\n        M.gEinj[np.random.permutation(N_mitral)[:100-int(param_dict['num_activated_mitral'])]]=0\n    \n    if param_dict['M_gEinj_base'] is None:\n        gEinj_base=M.gEinj # no oscillation of MC sensory inputs\n    else:\n        gEinj_base=param_dict['M_gEinj_base']\n        \n    M.taumKS=param_dict['M_taumKs']\n    M.tauI=param_dict['M_tauI']\n    M.tauI_G=param_dict['M_tauI_G']\n    M.gI_cst=param_dict['M_gI_cst']\n    freq_modul = param_dict['freq_modul']\n    phase_shifts = param_dict['MC_phase_dispersion']*randn(N_mitral) #3.0 # 0.3 // 2 // 5  (fig5C) #(fig3 and fig5 use 1.5) # fig4 uses 2.5 \n    \n    # M-M Weak inhibition\n    dm,dd=param_dict['weakinh_mean_delay'],param_dict['weakinh_delay_dispersion']\n    Cmm_weak_inh = Connection(M,M,'rI',\n                                                  weight=param_dict['weakinh_weight'],\n                                                  delay=(dm-dd,dm+dd), # mean delay +/- delay dispersion\n                                                  sparseness=param_dict['weakinh_connectproba'])\n    \n    # Only for LFP recording\n    Cmm_weak_inh2 = Connection(M,M,'rI2',weight=1.0)\n    \n    gEinj_max=M.gEinj.copy()\n    @network_operation()\n    def mitral_activation(clock):\n        if clock.t>t_init_M:\n            M.gEinj=(gEinj_max+gEinj_base)/2.+(gEinj_max-gEinj_base)/2.*cos(2*pi*freq_modul*Hz*clock.t+phase_shifts)\n        else :\n            M.gEinj=0.*siemens*meter**-2\n\n    #  Granule params\n    if use_granule:\n        # Granule model and initialization\n        N_granule=param_dict['N_granule']\n        G_input=param_dict['G_input']\n        phase_shifts_g=param_dict['GC_phase_dispersion']*randn(N_granule) # shift of phase to avoid artifact synchrony 0.2 base / 5 for vigile conditions\n        G_I_base=param_dict['G_I_base']\n        G_I_min=param_dict['G_I_min']\n        G_I_max=param_dict['G_I_max']\n\n        # Granule model and initialization\n        G=NeuronGroup(N_granule,QIF_eqs,threshold=0.*mV,reset=-70.*mV,freeze=True,compile=True)\n        G.V=-70.*mV\n        G.Iinj=G_I_base\n\n        # Dendro-dendritic connections\n        if not(param_dict['use_AMPA_STP']):\n            Cmg_AMPA = Connection(M,G,'sE',\n                                                    weight=param_dict['exc_weight'],\n                                                    sparseness=param_dict['stronginh_connectproba'],\n                                                    delay=1.*ms)\n        else: #withSTP\n            Cmg_AMPA = Connection(M,G,'sE',\n                                                    weight=2.5*param_dict['exc_weight'], # 2.5 factor to compensate for the depressed strength of AMPA in the beta regime\n                                                    sparseness=param_dict['stronginh_connectproba'],\n                                                    delay=1.*ms) #\n            mystp=STP(Cmg_AMPA,taud=150*ms,tauf=1*ms,U=1.)\n        \n        Cgm_GABA = Connection(G,M,'sI_G',delay=1.*ms) # synaptic weight is given later\n        connected=Cmg_AMPA.W.transpose().copy() # copy and transpose M->G connection array\n        mask_connect=(connected>0)\n        Cgm_GABA.connect(G,M,mask_connect*param_dict['stronginh_weight']) # finally create symmetrical connections\n        \n        # Time dependent activation of granule cells\n        @network_operation()\n        def granule_activation(clock):\n            if clock.t<t_init_G:\n                G.Iinj=G_I_base\n            else:               \n                if G_input=='sinusoid':\n                    G.Iinj=(G_I_max+G_I_min)/2.+(G_I_max-G_I_min)/2.*cos(2*pi*freq_modul*Hz*clock.t+phase_shifts_g+param_dict['GC_phase_shift'])\n                elif G_input=='ramp': # standard ramp : from -3.5nA to 0.5nA\n                        G.Iinj=G_I_min* (1.-(clock.t-t_init_G)/(sim_time-t_init_G)) + G_I_max*(clock.t-t_init_G)/(sim_time-t_init_G) # current ramp, linear from first to second current value \n                else:\n                    G.Iinj=G_I_base\n                \n\n    # Monitors\n    LFP=PopulationStateMonitor(M,'LFP') # actually it is \"fake\" Isyn which omits random delays (only spikes convolved with an IPSC waveform, averaged across all cells)\n    \n    if return_details: # Additional detailed recordings\n        recorded_mitrals=param_dict['recorded_mitrals']\n        SpikesM = SpikeMonitor(M)\n        Mpot=StateMonitor(M,'V',record=recorded_mitrals)\n        avgIsyn=PopulationStateMonitor(M,'Isyn')\n        Mvars=MultiStateMonitor(M,['Gsyn','Isyn','W','X','Y'],record=recorded_mitrals)\n        if use_granule:\n            recorded_granules=param_dict['recorded_granules']\n            SpikesG = SpikeMonitor(G)\n            Gpot=StateMonitor(G,'V',record=recorded_granules)\n            Gvars=MultiStateMonitor(G,['sE'],record=recorded_granules)\n            \n    # Simulation\n    run(sim_time,report=report)\n\n    if return_details:\n                \n        result_dict={}\n        result_dict['SpikesM_spikes']=SpikesM.spikes\n        if use_granule:\n            result_dict['SpikesG_spikes']=SpikesG.spikes\n            result_dict['N_granule']=N_granule\n            result_dict['Gpot_times']=Gpot.times\n            result_dict['Gpot_values']=Gpot.values\n        result_dict['N_mitral']=N_mitral\n        result_dict['LFP_times']=LFP.times\n        result_dict['LFP_values']=LFP.values\n        result_dict['Mpot_times']=Mpot.times\n        result_dict['Mpot_values']=Mpot.values\n        result_dict['avgIsyn_times']=avgIsyn.times\n        result_dict['avgIsyn_values']=avgIsyn.values\n        result_dict['Mvars_times']=Mvars.times\n        for name,mon in Mvars.items():\n            result_dict['Mvars_'+name+'_values']=Mvars[name].values        \n        result_dict['LFP_sr']=1./LFP.clock.dt\n        result_dict['M_gEinj']=M.gEinj\n        \n        return result_dict\n    else:\n        print \"One simulation done...\"\n        return LFP[0],1./LFP.clock.dt\n\nif __name__==\"__main__\":\n    \n    \n    from params_for_article_fig import *\n    \n    # Parameters to save simulation output\n    save_output=False\n    filename=\"test_dict_simplegamma\" # _multi.out ou _single.out sont automatiquement ajout\u00e9 apr\u00e8s le nom suivant le type de simul     \n    \n    # Detection osc params\n    osc_th=[0.1,0.1] # 0.2 for constant gamma or beta, 0.1 in presence of slow external modulations\n    freq_cut=40.\n    burn_time=1.*second\n    \n    if 1:  # To launch one network (with figures)\n\n        # ## Choose params\n        param_dict=param_dict_default.copy()\n        # ## Or choose one of the predefind parameter set (defined for article figures)\n        # param_dict=gamma_single_step_dict\n        # param_dict=beta_single_ramp_dict\n        # param_dict=competition_single_base_dict\n        # param_dict=competitionSTP_single_lowintensity_dict\n        # param_dict=competitionSTP_single_mediumintensity_dict\n        # param_dict=competitionSTP_single_highintensity_dict\n        # param_dict=competitionSTP_single_lowcentrifugal_dict\n        # param_dict=competitionSTP_single_highcentrifugal_dict\n        # param_dict=competitionSTP_single_awake\n        # param_dict=competitionSTP_single_awake_lowcentrifugal\n        \n        # Run single network \n        result_dict = reseau_mitral_granule(param_dict)\n        if save_output:\n            print \"Saving\"\n            import pickle\n            fid=open(filename+\"_single.out\",\"wb\")\n            pickle.dump([param_dict,result_dict],fid)\n            fid.close()\n            print \"Saved\"\n            \n        # Plot detailed results\n        single_LFP_analysis(result_dict,osc_th=osc_th,freq_cut=freq_cut,burn_time=burn_time)\n    \n    else: # To launch multiple network on different CPUs (only a synthesis figure is done)\n        \n        # Replace the parameter to vary with a numpy array of values to simulate\n        param_dict=param_dict_default.copy()\n        param_dict['weakinh_connectproba']=linspace(0.05,1.0,10)\n        # ## Or choose one of the predefind parameter set (defined for article figures)\n        # param_dict=gamma_multi_weakinhconnect_dict\n        # param_dict=gamma_multi_numact_dict\n        # param_dict=gamma_multi_weakinhweight_dict\n        # param_dict=gamma_multi_tauGABA_dict\n        # param_dict=gamma_multi_taumKs_dict\n        # param_dict=gamma_multi_MgEinj_dict\n        # param_dict=beta_multi_tauGABA_dict\n        # param_dict=beta_multi_stronginhweight_dict\n        # param_dict=beta_multi_GIinj_dict\n        # param_dict=beta_multi_excweight_dict\n        # param_dict=competition_multi_intensity\n        # param_dict=competitionSTP_multi_intensity\n        # param_dict=competitionSTP_multi_centrifugal_dict\n\n        number_of_runs = 10 # Number of runs for each paramater (with different inputs and random connectivity)\n\n        # Construct the list of param dictionaries for all simulations\n        list_dicts=[]\n        list_params=[]\n        for key,val in param_dict.items():\n            if (type(val)==ndarray)or((type(val)==list)and key[:8]!='recorded'):\n                for param in val:\n                    tmp_dict=param_dict.copy()\n                    tmp_dict[key]=param\n                    for i in range(number_of_runs):\n                        list_dicts.append(tmp_dict)\n                        list_params.append(param)\n        \n        # Third run multiple networks\n        import multiprocessing as mp\n        from functools import partial\n        pool=mp.Pool(10)\n        print \"Start simulations (no idea of how long it will be)\"\n        results=pool.map(partial(reseau_mitral_granule,return_details=False,report=None),list_dicts)\n        results=[(par,)+rr for par,rr in zip(list_params,results)] # Complete each result with its parameter\n        print \"finished : \",results\n\n        if save_output:\n            print \"Saving\"\n            import pickle\n            fid=open(filename+\"_multi.out\",\"wb\")\n            pickle.dump([param_dict,results],fid)\n            fid.close()\n            print \"Saved\"\n\n        # Example of analysis from data in results\n        distinct_figures=False\n        tmp_results=[res[:3] for res in results]  # To keep only LFP and param\n        multi_LFP_analysis(tmp_results,osc_th=osc_th,freq_cut=freq_cut,burn_time=burn_time,distinct_figures=distinct_figures)\n        # Spectrum plot\n        freq_min, freq_max =15.,90.\n        LFP_frequency_content(tmp_results,burn_time=burn_time,freq_min=freq_min,freq_max=freq_max)\n        \n    show()\n"
        ],
        "variables": [
            "section",
            "Clear",
            "simulation",
            "dictionaries",
            "avgIsyn_times",
            "otherwise",
            "nom",
            "avgIsyn",
            "data",
            "keep",
            "the",
            "vigile",
            "oscillation",
            "symmetrical",
            "wb",
            "inhibition",
            "strong",
            "script",
            "BRIAN",
            "sinusoid",
            "array",
            "test_dict_simplegamma",
            "If",
            "dd",
            "parameter",
            "MC",
            "G_input",
            "utf",
            "brian",
            "multiplied",
            "put",
            "mitral_activation",
            "vary",
            "competitionSTP_multi_intensity",
            "runs",
            "SpikeMonitor",
            "test",
            "current",
            "linspace",
            "pi",
            "term",
            "freq_max",
            "recordings",
            "brian_no_units",
            "stronginh_connectproba",
            "pure",
            "dump",
            "M_gEinj_base",
            "freq_cut",
            "set",
            "numpy",
            "Spectrum",
            "gEinj",
            "fucntion",
            "depression",
            "presence",
            "short",
            "synthesis",
            "number_of_runs",
            "ndarray",
            "connected",
            "an",
            "mask_connect",
            "One",
            "range",
            "delays",
            "long",
            "finished",
            "strength",
            "avgIsyn_values",
            "t",
            "rr",
            "pickle",
            "launch",
            "Gaussian",
            "params_for_article_fig",
            "simplify",
            "weakinh_weight",
            "beta_multi_stronginhweight_dict",
            "copy",
            "param",
            "tauI",
            "competitionSTP_single_awake",
            "network_operation",
            "function",
            "partial",
            "gamma_multi_tauGABA_dict",
            "done",
            "par",
            "beta_multi_GIinj_dict",
            "compile",
            "transpose",
            "mon",
            "None",
            "Parameters",
            "analysis",
            "Weak",
            "False",
            "Granule",
            "delay",
            "sim_time",
            "_values",
            "dict",
            "To",
            "provide",
            "Dendro",
            "given",
            "reinit_default_clock",
            "show",
            "choose",
            "weak",
            "rhythm",
            "by",
            "associated",
            "phase_shifts",
            "way",
            "MC_phase_dispersion",
            "weakinh_delay_dispersion",
            "gEinj_base",
            "G",
            "Mvars_times",
            "gamma",
            "gamma_single_step_dict",
            "averaged",
            "close",
            "tauI_G",
            "weight",
            "waveform",
            "taumKS",
            "Simulation",
            "CPUs",
            "Replace",
            "fig4",
            "vs",
            "freq_modul",
            "competition_multi_intensity",
            "Additional",
            "Mitral_reset",
            "second",
            "LFP_times",
            "Brian",
            "Dictionary",
            "in",
            "roles",
            "ou",
            "average",
            "G_I_max",
            "Connection",
            "coding",
            "burn_time",
            "func_param",
            "M_taumKs",
            "N_mitral",
            "memory",
            "predefind",
            "external",
            "random",
            "M_gEinj_shift",
            "le",
            "modulations",
            "spikes",
            "list_dicts",
            "during",
            "calibrated",
            "Check",
            "value",
            "nA",
            "Randomly",
            "_multi",
            "how",
            "time",
            "distinct_figures",
            "uniform",
            "V",
            "rand",
            "results",
            "sI_G",
            "automatiquement",
            "Mvars_",
            "reset",
            "ramp",
            "use",
            "basis",
            "Respiratory",
            "weakinh_connectproba",
            "clear",
            "synaptic",
            "Saving",
            "G_I_base",
            "contains",
            "cos",
            "__main__",
            "Construct",
            "if",
            "Mvars",
            "selection",
            "__name__",
            "Gsyn",
            "res",
            "X",
            "GC_phase_dispersion",
            "across",
            "simulate",
            "gamma_multi_MgEinj_dict",
            "t_init",
            "phase",
            "freeze",
            "beta_multi_excweight_dict",
            "networks",
            "W",
            "fig5C",
            "multi_LFP_analysis",
            "mitral",
            "parameters",
            "inh",
            "func_unit",
            "multiple",
            "Plot",
            "dispersion",
            "returned",
            "Iinj",
            "osc",
            "open",
            "single_LFP_analysis",
            "save_output",
            "default",
            "on",
            "model",
            "General",
            "min",
            "record",
            "LFPs",
            "rI",
            "return_details",
            "spectrum_analysis",
            "Number",
            "simul",
            "competitionSTP_single_lowintensity_dict",
            "values",
            "gamma_multi_numact_dict",
            "generate",
            "Start",
            "filename",
            "competitionSTP_single_lowcentrifugal_dict",
            "Detection",
            "gamma_multi_weakinhconnect_dict",
            "only",
            "for",
            "i",
            "freq_min",
            "compensate",
            "corresponds",
            "threshold",
            "t_init_M",
            "return",
            "Only",
            "competitionSTP_multi_centrifugal_dict",
            "M_gI_cst",
            "StateMonitor",
            "granule_activation",
            "NeuronGroup",
            "granule",
            "recorded_mitrals",
            "centrifugal",
            "Saved",
            "it",
            "no",
            "dendritic",
            "plot",
            "factor",
            "Hz",
            "Gpot_times",
            "of",
            "inputs",
            "competitionSTP_single_highcentrifugal_dict",
            "between",
            "as",
            "produced",
            "LFP_sr",
            "This",
            "one",
            "details",
            "_single",
            "osc_th",
            "or",
            "AMPA",
            "artifact",
            "at",
            "print",
            "else",
            "import",
            "generally",
            "final",
            "Cgm_GABA",
            "IPSC",
            "dm",
            "actually",
            "param_dict_default",
            "standard",
            "sparseness",
            "Automatically",
            "simulations",
            "Isyn",
            "de",
            "num_activated_mitral",
            "either",
            "avoid",
            "Time",
            "linear",
            "convolved",
            "idea",
            "multiprocessing",
            "and",
            "recording",
            "Run",
            "recorded",
            "connect",
            "Phase",
            "The",
            "randn",
            "PopulationStateMonitor",
            "list_params",
            "SpikesM",
            "M_tauI_G",
            "max",
            "Example",
            "slow",
            "Used",
            "detailed",
            "this",
            "True",
            "out",
            "cells",
            "constant",
            "Mpot_times",
            "Main",
            "tmp_results",
            "modulation",
            "GC_phase_shift",
            "shift",
            "plasticity",
            "LFP",
            "gamma_multi_taumKs_dict",
            "functools",
            "their",
            "MultiStateMonitor",
            "single",
            "use_granule",
            "beta_multi_tauGABA_dict",
            "stronginh_weight",
            "pool",
            "SpikesG",
            "not",
            "start",
            "uses",
            "SpikesG_spikes",
            "G_I_min",
            "SpikesM_spikes",
            "Choose",
            "be",
            "suivant",
            "permutation",
            "base",
            "Mitral_eqs",
            "beta",
            "gEinj_max",
            "populationstatemonitor",
            "fig5",
            "func_name",
            "siemens",
            "competitionSTP_single_highintensity_dict",
            "run",
            "fig3",
            "sont",
            "params",
            "objects",
            "map",
            "key",
            "Cmg_AMPA",
            "int",
            "plot_multi_run_from_file",
            "to",
            "taud",
            "omits",
            "Third",
            "save",
            "input",
            "intrinsic",
            "rI2",
            "Monitors",
            "its",
            "Y",
            "t_init_G",
            "recorded_granules",
            "defined",
            "excitation",
            "clock",
            "name",
            "activation",
            "activated",
            "Connectivity",
            "initialization",
            "connection",
            "Mpot_values",
            "Mpot",
            "figure",
            "QIF_eqs",
            "figures",
            "zip",
            "M_gEinj",
            "dt",
            "model_mitral_clean",
            "create",
            "N_granule",
            "finally",
            "np",
            "lot",
            "gI_cst",
            "connections",
            "type",
            "with",
            "STP",
            "respiratory",
            "dictionary",
            "regime",
            "param_dict",
            "inhibitory",
            "introduction",
            "beta_single_ramp_dict",
            "tauf",
            "use_AMPA_STP",
            "competition_single_base_dict",
            "sE",
            "Gpot",
            "tmp_dict",
            "main",
            "fake",
            "elif",
            "exc_weight",
            "Cmm_weak_inh2",
            "seed",
            "distribution",
            "a",
            "reseau_mitral_granule",
            "weakinh_mean_delay",
            "synchrony",
            "Cmm_weak_inh",
            "mp",
            "Complete",
            "distinct",
            "SD",
            "competitionSTP_single_mediumintensity_dict",
            "before",
            "will",
            "different",
            "Mitral",
            "output",
            "dependent",
            "many",
            "each",
            "ms",
            "mean",
            "first",
            "sensory",
            "phase_shifts_g",
            "fid",
            "report",
            "later",
            "mV",
            "Or",
            "Pool",
            "meter",
            "connectivity",
            "plot_single_run_from_file",
            "from",
            "beta_gamma_detection",
            "mystp",
            "items",
            "Gpot_values",
            "network",
            "M",
            "list",
            "val",
            "GC",
            "is",
            "which",
            "competitionSTP_single_awake_lowcentrifugal",
            "U",
            "article",
            "result",
            "Gvars",
            "gamma_multi_weakinhweight_dict",
            "shifts",
            "specific",
            "conductances",
            "result_dict",
            "conditions",
            "text",
            "all",
            "def",
            "LFP_frequency_content",
            "defaultclock",
            "used",
            "times",
            "LFP_values",
            "oscillation_analysis",
            "depressed",
            "M_tauI",
            "append",
            "decay",
            "withSTP",
            "paramater",
            "model_granule_clean"
        ]
    },
    "plot_single_run_from_file.py": {
        "comments": [
            "# -*- coding: utf-8 -*-\n\"\"\"\nThis script provides analysis and plot functions for detailed recordings issued from a single simulation.\nNote that a large part of the oscillation analysis (time frequency map, oscillation detection) is based on OpenElectrophy 0.2\n\nThe \"main\" section provides the way to plot results from a simulation output file \n\"\"\"\n\nfrom brian import *\nfrom oscillation_analysis import beta_gamma_detection, spectrum_analysis\nimport pylab as pl\nimport pickle\n\n\ndef single_LFP_analysis(result_dict,osc_th=0.06,freq_cut=40.,burn_time=0.8*second,xinf=None,xsup=None,clim_max=None):\n\n    # Oscillation analysis\n    LFPsig,LFPsr,SpikesM_spikes=result_dict['LFP_values'][0,:],result_dict['LFP_sr'],result_dict['SpikesM_spikes']\n    list_beta,list_gamma=beta_gamma_detection(LFPsig,LFPsr/Hz,freq_cut=freq_cut,verbose=False,plot_fig=True,osc_th=osc_th,burn_time=burn_time/second)\n\n    fig=gcf()\n    tfr_ax=fig.get_axes()\n    \n    if len(tfr_ax)>0: # test if time-frequency axis has been created (requires OpenElectrophy)\n        tfr_ax[0].set_xlim(xinf,xsup)\n        tfr_ax[1].set_ylim(-0.5,0.5)\n        img=tfr_ax[0].get_images()[0]\n        if clim_max is not None:\n            img.set_clim(0,clim_max) # usually 0.5 for gamma only and 0.15 competition\n\n    if 1:\n\n        spectrum_analysis(LFPsig,LFPsr,burn_time=burn_time,plot_fig=True,verbose=True)\n        beta_stats=[]\n        gamma_stats=[]\n        # Useful function to gather parameters of interest (amp and freq) from all oscillations in a list\n        def osc_stats(list_osc):\n            amps,freqs,timeinoscs=[],[],[]\n            for osc in list_osc:\n                amps.append(osc.amplitude_max)\n                freqs.append(osc.freq_max)\n                dur = osc.time_stop-osc.time_start\n                timeinoscs.append(dur)\n                print 'timeinosc=', sum(timeinoscs)\n            return mean(amps),mean(freqs),std(amps),std(freqs),sum(timeinoscs)\n\n        beta_stats.append(osc_stats(list_beta))\n        gamma_stats.append(osc_stats(list_gamma))\n        \n        # Plot data\n\n        SpikesM_spikes=result_dict['SpikesM_spikes']\n        N_mitral=result_dict['N_mitral']\n        LFP_times=result_dict['LFP_times']\n        LFP_values=result_dict['LFP_values']\n        if result_dict.has_key('avgIsyn_times'):\n            avgIsyn_times=result_dict['avgIsyn_times']\n            avgIsyn_values=result_dict['avgIsyn_values']\n        M_gEinj=result_dict['M_gEinj']\n        Mpot_times=result_dict['Mpot_times']\n        Mpot_values=result_dict['Mpot_values']\n        Mvars_times=result_dict['Mvars_times']\n        Isyn_values=result_dict['Mvars_Isyn_values']\n        Gsyn_values=result_dict['Mvars_Gsyn_values']\n        use_granule=result_dict.has_key('SpikesG_spikes')\n        if use_granule:\n            SpikesG_spikes=result_dict['SpikesG_spikes']\n            Gpot_times=result_dict['Gpot_times']\n            Gpot_values=result_dict['Gpot_values']\n\n        # Big figure with rasters, LFP, potentials and inhibitory input \n        fig=figure(figsize=(8,10))\n\n        ax=fig.add_subplot(611)\n        print \"number of mitral spikes : \",len(SpikesM_spikes)\n        if len(SpikesM_spikes)>0:\n            pl.scatter(array(SpikesM_spikes)[:,1],array(SpikesM_spikes)[:,0],s=2)\n            sps=array(SpikesM_spikes)\n            rates=[]\n            for i in range(N_mitral):\n                mitral_mask=(sps[:,0]==i)&(sps[:,1]*second>burn_time)\n                rates.append([i,mitral_mask.sum()/(LFP_times.max()-burn_time/second)])\n            rates=array(rates)\n        if use_granule:\n            print \"number of granule spikes : \",len(SpikesG_spikes)\n            if len(SpikesG_spikes)>0:\n                pl.scatter(array(SpikesG_spikes)[:,1],array(SpikesG_spikes)[:,0]+N_mitral,color='r',s=2)\n        ax.set_ylabel(\"raster\")\n        ax.set_xlim((xinf,xsup))\n\n        ax=fig.add_subplot(612,sharex=ax)\n        plot(LFP_times,LFP_values[0,:],linewidth=2)\n        ax.set_ylabel(\"LFP\")\n        ax.set_xlim((xinf,xsup))\n\n        ax=fig.add_subplot(613,sharex=ax)\n        for i in range(Mpot_values.shape[0]):\n            ax.plot(Mpot_times,Mpot_values[i,:]+0.04*i,linewidth=2)\n        ax.set_ylabel(\"Mitral potential\")\n        ax.set_xlim((xinf,xsup))\n\n        ax=fig.add_subplot(614,sharex=ax)\n        if result_dict.has_key('avgIsyn_times'):        \n            ax.plot(avgIsyn_times,avgIsyn_values[0,:])\n        else:\n            for i in range(Isyn_values.shape[0]):\n                ax.plot(Mvars_times,Isyn_values[i,:])\n        ax.set_ylabel(\"Syn Inh I\")\n        ax.set_xlim((xinf,xsup))\n\n        ax=fig.add_subplot(615,sharex=ax)\n        for i in range(Gsyn_values.shape[0]):\n            ax.plot(Mvars_times,Gsyn_values[i,:])\n        ax.set_ylabel(\"Syn Inh conduct.\")\n        ax.set_xlim((xinf,xsup))\n\n\n        if use_granule:\n            ax=fig.add_subplot(616,sharex=ax)\n            for i in range(Gpot_values.shape[0]):\n                ax.plot(Gpot_times,Gpot_values[i,:])\n            ax.set_ylabel(\"Granule pot\")\n            ax.set_xlim((xinf,xsup))\n            \n        checked_cells=[0,1,2,3,4]    \n        # Mitral internal variables\n        figure()\n        title(\"Mitral internal variables\")\n        list_colors=['r','b','m']\n        for i in checked_cells:\n            for name,col in zip(['X','Y','W'],list_colors):\n                plot(Mvars_times, result_dict['Mvars_'+name+'_values'][i,:], label=name,color=col)\n                if name=='W':\n                    nn=result_dict['Mvars_'+name+'_values'][i,:].size\n                    print \"Mean \",name,\" : \",result_dict['Mvars_'+name+'_values'][i,nn//2:].mean()\n            legend()\n            \n        # Mitral excitatory inputs\n        figure()\n        subplot(211)\n        bar(arange(M_gEinj.size),M_gEinj)\n        ylim(6,8)\n        title(\"Neuron excitatory inputs\")\n        subplot(212)\n        bar(rates[:,0],rates[:,1])\n        ylabel(\"Firing rates (Hz)\")\n        ylim(0,80)\n\n\nif __name__==\"__main__\":\n\n    # File to plot\n    list_filenames=[\"put_filename_root_here\"]\n    list_filenames=[\"test_dict_simplegamma\"]\n    \n    # Detection osc params\n    osc_th=[0.1, 0.1]  # Threshold for beta and gamma\n    freq_cut=40. \n    burn_time=0.8*second\n\n    for filename in list_filenames:\n\n        # Load data\n        fid=open(filename+\"_single.out\",\"rb\")\n        param_dict,result_dict=pickle.load(fid)\n        fid.close()\n\n        print \"Simulation params of plotted file: \",filename\n        for key,val in param_dict.items():\n            print key,': ',val\n        print\n\n        single_LFP_analysis(result_dict,osc_th=osc_th,freq_cut=freq_cut,burn_time=burn_time)\n\nshow()"
        ],
        "variables": [
            "of",
            "amp",
            "section",
            "second",
            "color",
            "LFP_times",
            "potentials",
            "inputs",
            "simulation",
            "in",
            "competition",
            "figure",
            "avgIsyn_times",
            "sharex",
            "as",
            "clim_max",
            "list_filenames",
            "verbose",
            "LFP_sr",
            "This",
            "zip",
            "M_gEinj",
            "amplitude_max",
            "time_stop",
            "data",
            "coding",
            "has",
            "burn_time",
            "LFPsr",
            "the",
            "N_mitral",
            "oscillation",
            "_single",
            "osc_th",
            "xinf",
            "based",
            "s",
            "subplot",
            "print",
            "amps",
            "script",
            "with",
            "import",
            "else",
            "excitatory",
            "spikes",
            "list_colors",
            "ylabel",
            "Gpot_times",
            "potential",
            "Threshold",
            "issued",
            "LFPsig",
            "Mvars_Isyn_values",
            "time",
            "array",
            "sum",
            "param_dict",
            "test_dict_simplegamma",
            "inhibitory",
            "results",
            "figsize",
            "Mvars_",
            "File",
            "large",
            "gather",
            "utf",
            "detection",
            "brian",
            "Inh",
            "main",
            "has_key",
            "add_subplot",
            "test",
            "std",
            "and",
            "get_images",
            "Useful",
            "timeinoscs",
            "bar",
            "freq_max",
            "recordings",
            "timeinosc",
            "a",
            "__main__",
            "if",
            "checked_cells",
            "The",
            "__name__",
            "set_ylim",
            "oscillations",
            "freq_cut",
            "set_clim",
            "X",
            "that",
            "rates",
            "pl",
            "max",
            "internal",
            "freqs",
            "detailed",
            "scatter",
            "variables",
            "True",
            "fig",
            "img",
            "out",
            "label",
            "W",
            "Oscillation",
            "Mitral",
            "conduct",
            "output",
            "beta_stats",
            "range",
            "Firing",
            "avgIsyn_values",
            "mitral",
            "parameters",
            "Mpot_times",
            "ylim",
            "part",
            "Syn",
            "mitral_mask",
            "pickle",
            "plotted",
            "m",
            "Plot",
            "LFP",
            "rb",
            "file",
            "mean",
            "single",
            "frequency",
            "gcf",
            "osc",
            "Mvars_Gsyn_values",
            "use_granule",
            "linewidth",
            "b",
            "legend",
            "single_LFP_analysis",
            "open",
            "gamma_stats",
            "put_filename_root_here",
            "not",
            "col",
            "fid",
            "function",
            "Mpot_values",
            "r",
            "Load",
            "been",
            "on",
            "load",
            "SpikesG_spikes",
            "shape",
            "SpikesM_spikes",
            "None",
            "usually",
            "tfr_ax",
            "analysis",
            "from",
            "ax",
            "False",
            "beta_gamma_detection",
            "spectrum_analysis",
            "list_osc",
            "sps",
            "Granule",
            "Neuron",
            "items",
            "Gpot_values",
            "list_gamma",
            "raster",
            "pot",
            "title",
            "OpenElectrophy",
            "list",
            "beta",
            "val",
            "is",
            "plot_fig",
            "_values",
            "get_axes",
            "Gsyn_values",
            "set_xlim",
            "functions",
            "result_dict",
            "filename",
            "xsup",
            "all",
            "params",
            "Detection",
            "map",
            "only",
            "key",
            "for",
            "i",
            "osc_stats",
            "show",
            "size",
            "time_start",
            "def",
            "to",
            "interest",
            "freq",
            "provides",
            "arange",
            "way",
            "input",
            "Mean",
            "return",
            "LFP_values",
            "Big",
            "axis",
            "created",
            "oscillation_analysis",
            "dur",
            "Mvars_times",
            "gamma",
            "append",
            "number",
            "granule",
            "Y",
            "pylab",
            "set_ylabel",
            "rasters",
            "Note",
            "name",
            "Isyn_values",
            "close",
            "plot",
            "Simulation",
            "len",
            "nn",
            "requires",
            "I",
            "Hz",
            "list_beta"
        ]
    },
    "plot_multi_run_from_file.py": {
        "comments": [
            "# -*- coding: utf-8 -*-\n\"\"\"\nThis script provides analysis and plot functions for LFP recordings issued from multiple simulations while varying a single parameter.\nNote that a large part of the oscillation analysis (time frequency map, oscillation detection) is based on OpenElectrophy 0.2\n\nThe \"main\" section provides the way to plot results from a simulation output file. \n\nFinally, it also allow to plot few spectograms of LFPs in a simulation output file.\n\"\"\"\n\nfrom brian import *\nfrom oscillation_analysis import beta_gamma_detection, spectrum_analysis\nimport pylab as pl\nimport pickle\nfrom scipy.stats import sem, nanmean, nanstd\n\n\n\ndef multi_LFP_analysis(results,osc_th=0.06,freq_cut=40.,burn_time=0.8,distinct_figures=False):\n    \"\"\"\n    result : list of (param,LFPsig,LFPsr)\n    From a list of LFPs with repetition of a set of param:\n    * detect oscillations in each LFP\n    * compute some oscillation properties \n    *compute and plot stats of properties across LFPs with the same param\n    \"\"\"\n\n    # Analysis of data in results\n    beta_stats=[]\n    gamma_stats=[]\n    params=[]\n    all_betas=[]\n    all_gammas=[]\n    all_LFPlengths=[]\n    for param,LFPsig,LFPsr in results: # Check each element recorded\n        params.append(param) # useful to get all simulated parameters\n        \n        # For that element compute beta and gamma oscillations\n        list_beta,list_gamma=beta_gamma_detection(LFPsig,LFPsr/Hz,freq_cut=freq_cut,osc_th=osc_th,burn_time=burn_time/second)\n        all_betas.append(list_beta)\n        all_gammas.append(list_gamma)\n        all_LFPlengths.append(1.*LFPsig.size/LFPsr-burn_time)\n\n    # Compute oscillation properties from all networks with the same parameter of interest, then compute mean and std of properties\n    final_list_params=unique(params)\n    params=array(params)\n    beta_stats=[]\n    gamma_stats=[]\n    for par in final_list_params:\n        \n        valid_par=where(params==par)[0]\n        \n        # Prepare to record stats from each recording\n        list_beta_stats=[]\n        list_gamma_stats=[]\n        \n        # Useful function to gather parameters of interest (amp and freq) from all oscillations in a list\n        def osc_stats(list_osc):\n            amps,freqs,timeinoscs=[],[],[]\n            for osc in list_osc:\n                amps.append(osc.amplitude_max)\n                freqs.append(osc.freq_max)\n                dur = (osc.time_stop-osc.time_start)/all_LFPlengths[ind] # proportion of total possible time\n                timeinoscs.append(dur)\n            return mean(amps),mean(freqs),sum(timeinoscs),len(amps)\n        \n        for ind in valid_par:\n            list_beta_stats.append(osc_stats(all_betas[ind]))\n            list_gamma_stats.append(osc_stats(all_gammas[ind]))\n            \n        list_beta_stats=array(list_beta_stats)\n        list_gamma_stats=array(list_gamma_stats)\n        \n        # Now compute stats on osc properties for all networks using the same param (use std or sem as wanted)\n        beta_stats.append([[nanmean(list_beta_stats[:,ind]),nanstd(list_beta_stats[:,ind])] for ind in range(list_beta_stats.shape[1])])\n        gamma_stats.append([[nanmean(list_gamma_stats[:,ind]),nanstd(list_gamma_stats[:,ind])] for ind in range(list_gamma_stats.shape[1])])\n        # beta_stats.append([[nanmean(list_beta_stats[:,ind]),sem(list_beta_stats[~isnan(list_beta_stats[:,ind]),ind])] for ind in range(list_beta_stats.shape[1])])\n        # gamma_stats.append([[nanmean(list_gamma_stats[:,ind]),sem(list_gamma_stats[~isnan(list_gamma_stats[:,ind]),ind])] for ind in range(list_gamma_stats.shape[1])])\n        \n        \n    # Tranform into arrays for simpler manipulation (shape : param, osc prop, mean/std)\n    beta_stats=array(beta_stats)\n    gamma_stats=array(gamma_stats)\n\n    lw=2 # linewidth for all curves\n\n    if distinct_figures:\n        figure()\n    else:\n        figure(10)\n    ax=subplot(411) # axis for amp vs param\n    errorbar(final_list_params,gamma_stats[:,0,0],yerr=gamma_stats[:,0,1],color='k',linewidth=lw)\n    errorbar(final_list_params,beta_stats[:,0,0],yerr=beta_stats[:,0,1],color='r',linewidth=lw)\n    ax.set_ylabel(\"Amplitude\")\n    pl.xlim(final_list_params[0],final_list_params[-1])\n    pl.ylim(ymin=0.2)\n\n    ax=subplot(412) # axis for freq vs param\n    errorbar(final_list_params,gamma_stats[:,1,0],yerr=gamma_stats[:,1,1],color='k',linewidth=lw)\n    errorbar(final_list_params,beta_stats[:,1,0],yerr=beta_stats[:,1,1],color='r',linewidth=lw)\n    pl.ylim(15,90)\n    pl.xlim(final_list_params[0],final_list_params[-1])\n    ax.set_ylabel(\"Frequency\")\n\n    ax=subplot(413) # total time spent in gamma and in beta\n    errorbar(final_list_params,gamma_stats[:,2,0],yerr=gamma_stats[:,2,1],color='k',linewidth=lw)\n    errorbar(final_list_params,beta_stats[:,2,0],yerr=beta_stats[:,2,1],color='r',linewidth=lw)\n    ax.set_ylabel(\"Length\")\n    pl.xlim(final_list_params[0],final_list_params[-1])\n    pl.ylim(ymin=0)\n\n    ax=subplot(414) # number of oscillations\n    errorbar(final_list_params,gamma_stats[:,3,0],yerr=gamma_stats[:,3,1],color='k',linewidth=lw)\n    errorbar(final_list_params,beta_stats[:,3,0],yerr=beta_stats[:,3,1],color='r',linewidth=lw)\n    ax.set_ylabel(\"Number\")\n    pl.xlim(final_list_params[0],final_list_params[-1])\n    pl.ylim(ymin=-1)\n    return\n    \ndef LFP_frequency_content(results,burn_time=0.8*second,freq_min=15.,freq_max=90.,verbose=False):\n    \"\"\"\n    Compute wavelet map (or FFT ?) of each LFP, to get an average spectral content for the whole LFP\n    Then compute mean and std (sem ?) of spectral profiles across LFP with the same param\n    Make a plot with all average profile on the same plot\n    \"\"\"\n\n    params=[]\n    all_spectrums=[]\n    \n    for param,LFPsig,LFPsr in results: # Check each element recorded\n        params.append(param) # useful to gather all simulated params\n        \n        Pxx,freqs=spectrum_analysis(LFPsig,LFPsr/Hz,burn_time=burn_time/second,plot_fig=False,verbose=verbose,return_full=True)\n        all_spectrums.append(Pxx)\n        \n    all_spectrums=array(all_spectrums)\n    params=array(params)\n    fig=figure()\n    ax=fig.add_subplot(111)\n    mask_freq=(freqs>=freq_min)&(freqs<=freq_max)\n    for ind,param in enumerate(unique(params)):\n        mask=params==param\n        ax.plot(freqs[mask_freq],all_spectrums[mask,:][:,mask_freq].mean(axis=0),label=str(param-4.),color=pl.cm.autumn(1.*(ind+1)/(len(unique(params)))),linewidth=2)\n    ax.legend()\n    ax.set_xlabel(\"Frequency (Hz)\")\n    ax.set_ylabel(\"LFP average spectrum\")\n\ndef plot_few_spectrograms(results,simul_to_plot=[0],osc_th=0.06,freq_cut=40.,burn_time=0.8*second):\n    \"\"\"\n    Detect oscillations and plot spectrogram for all simul indices in simul_to_plot\n    \"\"\"\n            \n    for ind in simul_to_plot:\n        param,LFPsig,LFPsr=results[ind] # Check each element recorded\n        print \"param: \",param\n    \n        # For that element compute beta and gamma oscillations\n        list_beta,list_gamma=beta_gamma_detection(LFPsig,LFPsr/Hz,freq_cut=freq_cut,osc_th=osc_th,burn_time=burn_time/second,plot_fig=True)\n        \n    return\n\nif __name__==\"__main__\":\n\n    distinct_figures=False\n\n    # Files to plot\n    list_filenames=[\"put_filename_root_here\"]\n    list_filenames=[\"test_dict_connectproba\"]\n    \n    # Detection osc params\n    osc_th=[0.2, 0.2] # oscillation threshold\n    freq_cut=40.\n    burn_time=0.8*second\n    \n    # Spectrum params\n    freq_min=15.\n    freq_max=90.\n\n    for filename in list_filenames:\n\n        # Load data\n        fid=open(filename+\"_multi.out\",\"rb\")\n        param_dict,results=pickle.load(fid)\n        fid.close()\n\n        print \"Simulation params of plotted file: \",filename \n        for key,val in param_dict.items():\n            print key,': ',val\n        print\n        \n        tmp_results=[res[:3] for res in results]  # To keep only LFP and param\n        multi_LFP_analysis(tmp_results,osc_th=osc_th,freq_cut=freq_cut,burn_time=burn_time,distinct_figures=distinct_figures)\n        LFP_frequency_content(tmp_results,burn_time=burn_time,freq_min=freq_min,freq_max=freq_max)\n        #~ plot_few_spectrograms(tmp_results,simul_to_plot=range(6),osc_th=osc_th,freq_cut=freq_cut,burn_time=burn_time)\n    \nshow()\n"
        ],
        "variables": [
            "all_betas",
            "of",
            "amp",
            "section",
            "nanmean",
            "second",
            "color",
            "str",
            "Detect",
            "simulation",
            "in",
            "figure",
            "wavelet",
            "as",
            "valid_par",
            "total",
            "verbose",
            "manipulation",
            "Tranform",
            "list_filenames",
            "This",
            "profiles",
            "list_beta_stats",
            "same",
            "data",
            "amplitude_max",
            "time_stop",
            "average",
            "coding",
            "keep",
            "burn_time",
            "LFPsr",
            "spent",
            "the",
            "oscillation",
            "osc_th",
            "or",
            "based",
            "nanstd",
            "subplot",
            "For",
            "spectral",
            "print",
            "stats",
            "amps",
            "script",
            "with",
            "import",
            "some",
            "else",
            "Pxx",
            "spectrum",
            "simul_to_plot",
            "Check",
            "issued",
            "prop",
            "LFPsig",
            "_multi",
            "few",
            "time",
            "array",
            "mask_freq",
            "while",
            "scipy",
            "distinct_figures",
            "sum",
            "param_dict",
            "content",
            "Files",
            "results",
            "simulations",
            "parameter",
            "large",
            "gather",
            "mask",
            "get",
            "utf",
            "detection",
            "use",
            "brian",
            "plot_few_spectrograms",
            "main",
            "Compute",
            "proportion",
            "properties",
            "Analysis",
            "add_subplot",
            "std",
            "and",
            "recording",
            "Useful",
            "timeinoscs",
            "Then",
            "compute",
            "freq_max",
            "recordings",
            "cm",
            "a",
            "recorded",
            "__main__",
            "if",
            "test_dict_connectproba",
            "The",
            "__name__",
            "varying",
            "oscillations",
            "freq_cut",
            "res",
            "that",
            "set",
            "Spectrum",
            "pl",
            "useful",
            "then",
            "across",
            "freqs",
            "Prepare",
            "xlim",
            "True",
            "unique",
            "fig",
            "set_xlabel",
            "an",
            "label",
            "out",
            "networks",
            "final_list_params",
            "output",
            "beta_stats",
            "range",
            "whole",
            "multi_LFP_analysis",
            "parameters",
            "ylim",
            "part",
            "tmp_results",
            "spectrogram",
            "pickle",
            "each",
            "possible",
            "multiple",
            "isnan",
            "simulated",
            "LFP",
            "rb",
            "plotted",
            "file",
            "mean",
            "single",
            "frequency",
            "osc",
            "linewidth",
            "legend",
            "param",
            "open",
            "autumn",
            "gamma_stats",
            "lw",
            "k",
            "put_filename_root_here",
            "element",
            "fid",
            "function",
            "r",
            "ind",
            "Load",
            "par",
            "list_gamma_stats",
            "on",
            "load",
            "shape",
            "Length",
            "LFPs",
            "record",
            "ax",
            "analysis",
            "from",
            "spectograms",
            "errorbar",
            "detect",
            "False",
            "beta_gamma_detection",
            "spectrum_analysis",
            "list_osc",
            "allow",
            "From",
            "ymin",
            "items",
            "Number",
            "list_gamma",
            "simul",
            "wanted",
            "OpenElectrophy",
            "profile",
            "list",
            "beta",
            "val",
            "curves",
            "is",
            "plot_fig",
            "all_spectrums",
            "using",
            "Make",
            "all_LFPlengths",
            "result",
            "arrays",
            "yerr",
            "also",
            "simpler",
            "To",
            "functions",
            "FFT",
            "filename",
            "all",
            "params",
            "indices",
            "Detection",
            "map",
            "key",
            "only",
            "for",
            "freq_min",
            "osc_stats",
            "show",
            "size",
            "time_start",
            "def",
            "threshold",
            "to",
            "interest",
            "freq",
            "provides",
            "sem",
            "return_full",
            "into",
            "LFP_frequency_content",
            "way",
            "Amplitude",
            "return",
            "axis",
            "where",
            "oscillation_analysis",
            "all_gammas",
            "dur",
            "Frequency",
            "gamma",
            "append",
            "number",
            "enumerate",
            "pylab",
            "set_ylabel",
            "Note",
            "Finally",
            "repetition",
            "it",
            "Now",
            "close",
            "plot",
            "Simulation",
            "len",
            "vs",
            "Hz",
            "list_beta"
        ]
    },
    "params_for_article_fig.py": {
        "comments": [
            "# -*- coding: utf-8 -*-\n\"\"\"\nThis script provides parameter dictionaries for all article figures.\nNote the dictionaries are based on the default dictionary from reseau_mitral_granule_fig_param_dic.py\n\"\"\"\n\nfrom brian import *\nfrom reseau_mitral_granule_fig_param_dic import param_dict_default\n\n# Figure 2B-2C\ngamma_single_step_dict=param_dict_default.copy()\ngamma_single_step_dict['t_init_M']=1.*second\n\n# Figure 2D\ngamma_multi_weakinhconnect_dict=param_dict_default.copy()\ngamma_multi_weakinhconnect_dict['weakinh_connectproba']=linspace(0.05,1.,20)\n\n# Figure 2E\ngamma_multi_numact_dict=param_dict_default.copy()\ngamma_multi_numact_dict['num_activated_mitral']=linspace(5,100,20)\n\n# Figure 2F\ngamma_multi_weakinhweight_dict=param_dict_default.copy()\ngamma_multi_weakinhweight_dict['weakinh_weight']=[x*ms for x in linspace(0.1,2.,20)]\n\n# Figure 2G\ngamma_multi_tauGABA_dict=param_dict_default.copy()\ngamma_multi_tauGABA_dict['M_tauI']=linspace(0.1,2.,20)\n\n# Figure 2H\ngamma_multi_taumKs_dict=param_dict_default.copy()\ngamma_multi_taumKs_dict['M_taumKs']=[x*ms for x in linspace(1.,20.,20)]\n\n# Figure 2I (TODO: improve to give final parameters instead of shifts)\ngamma_multi_MgEinj_dict=param_dict_default.copy()\ngamma_multi_MgEinj_dict['M_gEinj_shift']=linspace(-1.2,2.5,10)\n\n# Figure 3B-C\nbeta_single_ramp_dict=param_dict_default.copy()\nbeta_single_ramp_dict['sim_time']=3.5*second\nbeta_single_ramp_dict['use_granule']=True\nbeta_single_ramp_dict['t_init_G']=2.*second\nbeta_single_ramp_dict['G_input']='ramp'\nbeta_single_ramp_dict['G_I_base']=-3.5*nA\nbeta_single_ramp_dict['G_I_min']=-3.5*nA\nbeta_single_ramp_dict['G_I_max']=0.5*nA\n\n# Figure 3D, also used as base for beta_multi\nbeta_base_dict=param_dict_default.copy()\nbeta_base_dict['use_granule']=True\nbeta_base_dict['G_input']='constant'\nbeta_base_dict['G_I_base']=-1.5*nA\n\n# Figure 3E\nbeta_multi_tauGABA_dict=beta_base_dict.copy()\nbeta_multi_tauGABA_dict['M_tauI_G']=[x*ms for x in linspace(3.,16.,20)]\n\n# Figure 3F\nbeta_multi_stronginhweight_dict=beta_base_dict.copy()\nbeta_multi_stronginhweight_dict['stronginh_weight']=linspace(.1,3.,20)\n\n# Figure 3G\nbeta_multi_GIinj_dict=beta_base_dict.copy()\nbeta_multi_GIinj_dict['G_I_base']=[x*nA for x in linspace(-2.5,.2,20)]\n\n# Figure 3H\nbeta_multi_excweight_dict=beta_base_dict.copy()\nbeta_multi_excweight_dict['exc_weight']=linspace(.1,2.,20)\n\n# Figure 4E-4G\ncompetition_single_base_dict=param_dict_default.copy()\ncompetition_single_base_dict['M_gEinj_base']=4.*siemens*meter**-2\ncompetition_single_base_dict['M_gEinj']=(linspace,(6.6,8.1,100),siemens*meter**-2)\ncompetition_single_base_dict['use_granule']=True\ncompetition_single_base_dict['G_input']='sinusoid'\n\n# Figure 5C1-5C2 low intensity\ncompetitionSTP_single_lowintensity_dict=competition_single_base_dict.copy()\ncompetitionSTP_single_lowintensity_dict['use_AMPA_STP']=True\ncompetitionSTP_single_lowintensity_dict['MC_phase_dispersion']=5.\n\n# Figure 5C1-5C2 medium intensity\ncompetitionSTP_single_mediumintensity_dict=competition_single_base_dict.copy()\ncompetitionSTP_single_mediumintensity_dict['use_AMPA_STP']=True\ncompetitionSTP_single_mediumintensity_dict['MC_phase_dispersion']=1.3\n\n# Figure 5C1-5C2 high intensity\ncompetitionSTP_single_highintensity_dict=competition_single_base_dict.copy()\ncompetitionSTP_single_highintensity_dict['use_AMPA_STP']=True\ncompetitionSTP_single_highintensity_dict['MC_phase_dispersion']=0.2\n\n# Figure 5D1-5D2 no STP\ncompetition_multi_intensity=competition_single_base_dict.copy()\ncompetition_multi_intensity['MC_phase_dispersion']=[5., 4., 3., 2.5, 2.0, 1.5, 1.0, 0.5, 0.2, 0.1, 0.05, 0.]\n\n# Figure 5D1-5D2 with STP\ncompetitionSTP_multi_intensity=competition_single_base_dict.copy()\ncompetitionSTP_multi_intensity['MC_phase_dispersion']=[5., 4., 3., 2.5, 2.0, 1.5, 1.0, 0.5, 0.2, 0.1, 0.05, 0.]\ncompetitionSTP_multi_intensity['use_AMPA_STP']=True\n\n# Figure 6B-6C low centrifugal input\ncompetitionSTP_single_lowcentrifugal_dict=competition_single_base_dict.copy()\ncompetitionSTP_single_lowcentrifugal_dict['use_AMPA_STP']=True\ncompetitionSTP_single_lowcentrifugal_dict['G_I_max']=-0.5*nA\n\n# Figure 6B-6C high centrifugal input\ncompetitionSTP_single_highcentrifugal_dict=competition_single_base_dict.copy()\ncompetitionSTP_single_highcentrifugal_dict['use_AMPA_STP']=True\ncompetitionSTP_single_highcentrifugal_dict['G_I_max']=0.*nA\n\n# Figure 6D-6E high centrifugal input\ncompetitionSTP_multi_centrifugal_dict=competition_single_base_dict.copy()\ncompetitionSTP_multi_centrifugal_dict['use_AMPA_STP']=True\ncompetitionSTP_multi_centrifugal_dict['G_I_max']=[x*nA for x in [-0.6, -0.5, -0.4, -0.3, -0.25, -0.2, -0.15, -0.1, -0.05, 0.]]\n\n# Figure 7 high centrifugal, used as a basis dict for the low centrifugal\ncompetitionSTP_single_awake=competition_single_base_dict.copy()\ncompetitionSTP_single_awake['sim_time']=2.*second\ncompetitionSTP_single_awake['freq_modul']=8.*Hz\ncompetitionSTP_single_awake['M_gEinj']=(linspace,(6.1,7.6,100),siemens*meter**-2)\ncompetitionSTP_single_awake['M_gEinj_base']=5.9*siemens*meter**-2\ncompetitionSTP_single_awake['use_AMPA_STP']=True\ncompetitionSTP_single_awake['GC_phase_dispersion']=5.\n# Figure 7 low centrifugal\ncompetitionSTP_single_awake_lowcentrifugal=competitionSTP_single_awake.copy()\ncompetitionSTP_single_awake_lowcentrifugal['G_I_max']=-1.5*nA"
        ],
        "variables": [
            "of",
            "second",
            "in",
            "reseau_mitral_granule_fig_param_dic",
            "dictionaries",
            "competitionSTP_single_highcentrifugal_dict",
            "as",
            "figures",
            "This",
            "beta_base_dict",
            "M_gEinj",
            "G_I_max",
            "coding",
            "instead",
            "M_taumKs",
            "the",
            "based",
            "M_gEinj_shift",
            "script",
            "with",
            "import",
            "final",
            "STP",
            "sinusoid",
            "nA",
            "dictionary",
            "param_dict_default",
            "TODO",
            "competition_single_base_dict",
            "use_AMPA_STP",
            "parameter",
            "num_activated_mitral",
            "ramp",
            "G_input",
            "utf",
            "brian",
            "basis",
            "competitionSTP_multi_intensity",
            "weakinh_connectproba",
            "linspace",
            "exc_weight",
            "G_I_base",
            "a",
            "M_gEinj_base",
            "M_tauI_G",
            "GC_phase_dispersion",
            "competitionSTP_single_mediumintensity_dict",
            "gamma_multi_MgEinj_dict",
            "True",
            "beta_multi_excweight_dict",
            "py",
            "constant",
            "parameters",
            "medium",
            "gamma_multi_taumKs_dict",
            "ms",
            "x",
            "use_granule",
            "weakinh_weight",
            "beta_multi",
            "beta_multi_tauGABA_dict",
            "beta_multi_stronginhweight_dict",
            "copy",
            "stronginh_weight",
            "intensity",
            "competitionSTP_single_awake",
            "give",
            "gamma_multi_tauGABA_dict",
            "default",
            "on",
            "beta_multi_GIinj_dict",
            "G_I_min",
            "meter",
            "from",
            "high",
            "base",
            "competitionSTP_single_lowintensity_dict",
            "gamma_multi_numact_dict",
            "sim_time",
            "competitionSTP_single_awake_lowcentrifugal",
            "are",
            "article",
            "C",
            "gamma_multi_weakinhweight_dict",
            "shifts",
            "also",
            "siemens",
            "dict",
            "competitionSTP_single_highintensity_dict",
            "all",
            "competitionSTP_single_lowcentrifugal_dict",
            "gamma_multi_weakinhconnect_dict",
            "for",
            "low",
            "to",
            "t_init_M",
            "provides",
            "MC_phase_dispersion",
            "input",
            "used",
            "competitionSTP_multi_centrifugal_dict",
            "Figure",
            "M_tauI",
            "gamma_single_step_dict",
            "Hz",
            "t_init_G",
            "centrifugal",
            "Note",
            "no",
            "improve",
            "freq_modul",
            "competition_multi_intensity",
            "beta_single_ramp_dict"
        ]
    },
    "model_mitral_clean.py": {
        "comments": [
            "# -*- coding: utf-8 -*-\n\"\"\"\nThis script provides equations for the mitral model initially\npublished in David et al. (2009, PLOS Comp Biology)\n\"\"\"\n\nfrom brian import *\n\nprint \"Mitral equation initialization\"\n\n# Mitral membrane and ionic current params\nCm     = 0.01*farad*meter**-2 \ngL     = 0.1*siemens*meter**-2 \nEL     = -66.5*mV \ngNa    = 500*siemens*meter**-2\ngNap   = 1.1*siemens*meter**-2\ngKA    = 100.*siemens*meter**-2\ngKS    = 310.*siemens*meter**-2\ngKF    = 100.*siemens*meter**-2\nmhKA   = 0.004\nENa    = 45.*mV\nEK     = -75.*mV\ntaumKF = 2.6*ms\n\n# Synaptic current params\nEe = 0.*mV\nEi = -70.*mV\ntauIr = 2.*ms # Weak inhibition synapse rise time\ngI_max=0.18*siemens*meter**-2 # Weak inhibition max conductance (conductance time integral depends on rise time)\ngI_G=3.0*siemens*meter**-2 # Strong inhibition max conductance \n\nMitral_eqs=Equations('''\ndV/dt=(-gL*(V-EL)-gNa*mNa*mNa*mNa*(V-ENa)-gKA*mhKA*(V-EK)-gKS*W*X*(V-EK)-gNap/(1.+exp(-(V+51.*mV)/(5.*mV)))*(V-ENa)-gKF*Y*(V-EK) + Iinj - gEinj * (V-Ee) - (gI_cst + sI * gI_max + sI_G * gI_G)  * (V-Ei) )/Cm : volt\ndW/dt = ( 1./( exp( -(V+34.*mV)/(6.5*mV) ) + 1.) - W ) / taumKS : 1\ndX/dt = 2.*( 1./( exp(  (V+65.*mV)/(6.6*mV) ) + 1.) - X ) / ((200. + 220./( exp(-(V+71.6*mV)/(6.85*mV)) + 1.))*ms) : 1\ndY/dt = -Y/taumKF : 1\naNa=0.32 * (-(V+50.*mV))/( exp(-(V+50.*mV)/(4.*mV)) - 1. ) : mV\nbNa=0.28 * (V+23.*mV) / (exp((V+23.*mV)/(5.*mV)) - 1. )  : mV\nmNa=aNa/(aNa+bNa) : 1\ndsI/dt = (rI -sI) /tauI: 1\ndrI/dt= -rI/tauIr : 1\ndsI_G/dt = -sI_G /tauI_G : 1\nIinj : amp*meter**-2\ngEinj : siemens*meter**-2\ntaumKS : ms\ntauI : ms\ntauI_G : ms\ngI_cst : siemens*meter**-2\n\ndsI2/dt = (rI2 -sI2) /tauI: 1\ndrI2/dt= -rI2/tauIr : 1\nLFP=sI2 * gI_max :siemens*meter**-2\n\nIsyn=- (sI * gI_max + sI_G * gI_G)  * (V-Ei) :amp*meter**-2\nIsyn_all=(- gEinj * (V-Ee) - (gI_cst + sI * gI_max + sI_G * gI_G)  * (V-Ei)) :amp*meter**-2\nGsyn=(sI * gI_max + sI_G * gI_G):siemens*meter**-2\n''')\n\ndef Mitral_reset(P, spikes):\n    P.V[spikes]=-65.*mV # -70*mV in UB4.c\n    P.W[spikes]+=0.03 # mKs, 0.03 in UB4.c\n    P.X[spikes]+=0.002 # hKs\n    P.Y[spikes]+=0.4 # mKf"
        ],
        "variables": [
            "Mitral_reset",
            "amp",
            "mhKA",
            "PLOS",
            "in",
            "mKs",
            "membrane",
            "This",
            "Cm",
            "dt",
            "Synaptic",
            "coding",
            "the",
            "sI",
            "gKA",
            "gNap",
            "tauIr",
            "inhibition",
            "print",
            "gI_cst",
            "script",
            "import",
            "spikes",
            "dV",
            "equations",
            "time",
            "gKF",
            "drI2",
            "volt",
            "V",
            "sI_G",
            "EK",
            "depends",
            "ionic",
            "Isyn",
            "Comp",
            "utf",
            "brian",
            "dsI2",
            "David",
            "current",
            "et",
            "and",
            "equation",
            "Ee",
            "Equations",
            "al",
            "Gsyn",
            "X",
            "EL",
            "taumKF",
            "mKf",
            "gEinj",
            "max",
            "gL",
            "dsI_G",
            "c",
            "W",
            "Mitral",
            "Strong",
            "gNa",
            "gI_max",
            "drI",
            "P",
            "mitral",
            "exp",
            "integral",
            "LFP",
            "ms",
            "Iinj",
            "dX",
            "tauI",
            "hKs",
            "dsI",
            "rise",
            "sI2",
            "mV",
            "ENa",
            "on",
            "model",
            "meter",
            "from",
            "rI",
            "farad",
            "Weak",
            "synapse",
            "conductance",
            "Mitral_eqs",
            "Ei",
            "siemens",
            "initially",
            "bNa",
            "params",
            "for",
            "gKS",
            "def",
            "provides",
            "dW",
            "dY",
            "Biology",
            "mNa",
            "rI2",
            "aNa",
            "Y",
            "gI_G",
            "tauI_G",
            "taumKS",
            "published",
            "Isyn_all",
            "UB4",
            "initialization"
        ]
    },
    "model_granule_clean.py": {
        "comments": [
            "# -*- coding: utf-8 -*-\n\"\"\"\nSimple quadratic integrate-and-fire (QIF) model for the granule cells.\nParameters were fitted to match model f-I curve with granule f-I curve of Davison (2001, PhD Thesis)\n\"\"\"\n\nfrom brian import *\n\nprint \"Granule equation initialization\"\n\n# Granule membrane parameters\nV_T=-60.*mV\nI_T=0.02*nA # threshold of the Davison f-I curve\n\n# All next 3 variables are linked to reproduce the Davison f-I curve (# example with a multiplicative factor)\nDelta_T=0.1*mV # Delta_T*factor\ntau_m=60*ms # tau_m/factor\ngL_G=16.666*nS # gL_G*factor => not a real leak constant (because such a constant has no meaning in a QIF model)\n\n\n# Synaptic current parameters\ntauE=3.*ms\nEe = 0.*mV\ngE_max=4.*nS # gE_max*factor <-- if excitation must remain the same when a factor is applied above\n \nQIF_eqs=\"\"\"\ndV/dt =  ((1/(2*Delta_T))*(V-V_T)**2 - I_T/gL_G + Iinj/gL_G - (sE*gE_max + gEinj)/gL_G*(V-Ee))/tau_m  : volt\nIinj : amp\ngEinj : siemens\ndsE/dt = -sE/tauE : 1\n\"\"\"\n\ndef QIF_reset(P, spikes):\n    P.V[spikes]=-70.*mV # -70*mV in UB4.c"
        ],
        "variables": [
            "of",
            "amp",
            "applied",
            "in",
            "Delta_T",
            "QIF_eqs",
            "membrane",
            "nS",
            "same",
            "dt",
            "Synaptic",
            "real",
            "coding",
            "has",
            "the",
            "example",
            "print",
            "with",
            "import",
            "must",
            "spikes",
            "nA",
            "dV",
            "QIF_reset",
            "volt",
            "V",
            "sE",
            "utf",
            "brian",
            "QIF",
            "current",
            "and",
            "equation",
            "Ee",
            "reproduce",
            "a",
            "if",
            "integrate",
            "next",
            "gEinj",
            "PhD",
            "Simple",
            "variables",
            "c",
            "cells",
            "such",
            "P",
            "constant",
            "parameters",
            "ms",
            "Davison",
            "Iinj",
            "All",
            "not",
            "mV",
            "tauE",
            "remain",
            "model",
            "Parameters",
            "from",
            "multiplicative",
            "Granule",
            "meaning",
            "quadratic",
            "I_T",
            "is",
            "are",
            "UB4",
            "linked",
            "siemens",
            "gL_G",
            "curve",
            "because",
            "for",
            "def",
            "threshold",
            "tau_m",
            "to",
            "leak",
            "f",
            "fire",
            "fitted",
            "granule",
            "were",
            "excitation",
            "match",
            "no",
            "when",
            "gE_max",
            "above",
            "V_T",
            "Thesis",
            "dsE",
            "I",
            "factor",
            "initialization"
        ]
    },
    "oscillation_analysis.py": {
        "comments": [
            "# -*- coding: utf-8 -*-\n\"\"\"\nThis script allows frequency analysis and oscillation detection on LFP recordings, it is based on OpenElectrophy 0.2\nwhich can be downloaded here:\n\nhttp://neuralensemble.org/trac/OpenElectrophy\n\"\"\"\n\nimport distutils.version\nimport numpy\n\nif distutils.version.LooseVersion(numpy.__version__)<'1.4':\n    print \"Numpy version checked\"\n    from numpy import setmember1d as in1d\n    \nimport sys\n# Path to OpenElectrophy 0.2 must be provided here\nsys.path=[\"/home/nfourcau/OpenElectrophy_svn/OpenElectrophy/trunk/\"]+sys.path\n\ntry:\n    import OpenElectrophy as oe\n    test_oe= (distutils.version.LooseVersion(oe.__version__)<'0.3') and (distutils.version.LooseVersion(oe.__version__)>='0.2')\n    assert test_oe, 'Bad version of OpenElectrophy {}'.format( OE2.__version__ )\n    from OpenElectrophy import *\n    print\n    print \"Successful import of OpenElectrophy 0.2\"\n    print\n    oe_valid=True\nexcept:\n    print\n    print \"Failure to import OpenElectrophy 0.2\"\n    print\n    oe_valid=False\n\ndef spectrum_analysis(sig,sr,burn_time=0.,plot_fig=False,verbose=False,return_full=False):\n    \"\"\"\n    Compute the signal spectrum\n    Assume sr is in Hz and burn time in second\n    \"\"\"\n    \n    # LFP analysis\n    sig_mask=(1.*arange(sig.size)/sr)>burn_time\n    NFFTpoints=int(.5*sr)\n    pyplot.figure()\n    Pxx,freqs=pyplot.psd(sig, NFFT=NFFTpoints, Fs=sr, detrend=pyplot.mlab.detrend_mean,\n          window=pyplot.mlab.window_hanning, noverlap=NFFTpoints/2, pad_to=None)\n    if plot_fig:\n        pyplot.xlim(0,150)\n    else:\n        pyplot.close()\n        \n    if verbose: \n        print \"LFP max (freq and value):\"\n        print freqs[Pxx.argmax()],Pxx.max()\n    \n    if return_full:\n        return Pxx,freqs\n    else:\n        return freqs[Pxx.argmax()],Pxx.max()\n\n\ndef beta_gamma_detection(signal,sr,freq_cut=40,verbose=False,plot_fig=False,osc_th=None,burn_time=0.):\n    \"\"\"\n    Detect beta and gamma oscillation (separation between both is given by freq_cut)\n    \n    Osc_th can be a float for a global threshold or a list of 2 float. In the latter case it assumed to be beta then gamma threshold\n    Assume sr is in Hz and burn time in second\n    \"\"\"     \n\n    if oe_valid:\n\n        if type(osc_th)!=type([]):\n            osc_th=[osc_th]\n\n        anaSig=AnalogSignal(signal=signal-signal.mean(),sampling_rate=sr)\n\n        # LineDetector has the same parameters as the UI:\n        lineDetector = LineDetector(anaSig,\n                            #scalogram\n                            f_start=10.,\n                            f_stop=100.,\n                            # detection_zone\n                            detection_zone = [ burn_time, inf , 10., 100.],\n                            # threshold\n                            manual_threshold = (osc_th[0]!=None),\n                            abs_threshold= osc_th[0], \n                            std_relative_threshold = 3.,\n                            reference_zone = [ -inf, 1, 10., 100.],\n                            # clean\n                            minimum_cycle_number= 2.0,\n                            eliminate_simultaneous = True,\n                            regroup_full_overlap = True , \n                            eliminate_partial_overlap = True,      \n                            )\n\n        if len(osc_th)==1:\n            lineDetector.computeAllStep()\n            \n            # you want to inspect all detected oscillations:\n            if verbose:\n                for osci in lineDetector.list_oscillation:\n                    print osci.time_start, osci.time_stop\n                    print osci.freq_start, osci.freq_stop\n                    print osci.time_line, osci.freq_line, osci.value_line\n                \n                    \n            list_gamma=[]\n            list_beta=[]\n            for osci in lineDetector.list_oscillation:\n                if osci.freq_max<freq_cut:\n                    list_beta.append(osci)\n                else:\n                    list_gamma.append(osci)\n        \n        else:\n            # First detect beta\n            lineDetector.detection_zone=[ burn_time, inf , 10., freq_cut]\n            lineDetector.computeAllStep()\n            list_beta=copy(lineDetector.list_oscillation)\n            # Second detect gamma\n            lineDetector.detection_zone=[ burn_time, inf , freq_cut, 100.]\n            lineDetector.abs_threshold=osc_th[1]\n            lineDetector.computeAllStep()\n            list_gamma=copy(lineDetector.list_oscillation)\n            # Put back everything for plotting\n            lineDetector.list_oscillation=r_[list_beta,list_gamma]\n            lineDetector.detection_zone=[ burn_time, inf , 10., 100.]\n            \n        if 1: # This part can be useful only if \n            # (1) \"eliminate_simultaneous\" is set to False in lineDetector \n            # or (2) two threshold were used\n            # It shortens simultaneous beta and gamma to avoid overlap\n            # (this is slightly artificial)\n            def recomp_osc_properties(osc):\n                if osc.time_line.size>0:\n                    osc.amplitude_max=float(abs(osc.value_line).max())\n                    ind_max=abs(osc.value_line).argmax()\n                    osc.time_max=float(osc.time_line[ind_max])\n                    osc.freq_max= float(osc.freq_line[ind_max])\n                    osc.time_start=float(osc.time_line[0])\n                    osc.freq_start=float(osc.freq_line[0])\n                    osc.time_stop=float(osc.time_line[-1])\n                    osc.freq_stop=float(osc.freq_line[-1])\n                return osc\n            \n            for gamma in list_gamma:\n                for beta in list_beta:\n                    if intersect1d(gamma.time_line,beta.time_line).size != 0 :\n                        ind_gamma=in1d(gamma.time_line,beta.time_line)#in1d(gamma.time_line,beta.time_line)\n                        ind_beta=in1d(beta.time_line,gamma.time_line)#in1d(beta.time_line,gamma.time_line)\n                        compare_osc=(abs(gamma.value_line)[ind_gamma])>(abs(beta.value_line)[ind_beta])\n                        #~ print \"comp \",compare_osc\n                        if compare_osc[0]:\n                            osc1=gamma\n                            ind1=ind_gamma\n                            osc2=beta\n                            ind2=ind_beta\n                        else:\n                            osc1=beta\n                            ind1=ind_beta\n                            osc2=gamma\n                            ind2=ind_gamma\n                        ind_osc1_keep=ind1.copy()\n                        ind_osc1_keep=ind_osc1_keep[ind1]\n                        if any(compare_osc)&any(~compare_osc):\n                            cut=where(compare_osc!=compare_osc[0])[0][0]\n                        elif not(compare_osc[0]):\n                            cut=compare_osc.size\n                        elif compare_osc[0]:\n                            cut=0\n                        ind_osc1_keep[cut:]=False\n                        ind1_keep=r_[~(ind1[~ind1]),ind_osc1_keep]\n                        ind2_keep=r_[~ind_osc1_keep,~(ind2[~ind2])]\n                        osc1.time_line=osc1.time_line[ind1_keep]\n                        osc1.freq_line=osc1.freq_line[ind1_keep]\n                        osc1.value_line=osc1.value_line[ind1_keep]\n                        osc1=recomp_osc_properties(osc1)\n                        osc2.time_line=osc2.time_line[ind2_keep]\n                        osc2.freq_line=osc2.freq_line[ind2_keep]\n                        osc2.value_line=osc2.value_line[ind2_keep]\n                        osc2=recomp_osc_properties(osc2)\n            \n            def f_test(osc): return osc.time_line.size>0\n            if __name__==\"__main__\":\n                list_filter=__builtins__.filter\n            else:\n                list_filter=__builtins__['filter']\n            list_gamma=list_filter(f_test, list_gamma)\n            list_beta=list_filter(f_test, list_beta)\n            lineDetector.list_oscillation=list_filter(f_test, lineDetector.list_oscillation)\n                    \n        # for plotting PLotLineDetecor is based on matplotlib\n        if plot_fig:\n            fig = pyplot.figure()\n            plotLineDetector = PlotLineDetector(figure = fig , \n                                        lineDetector = lineDetector,)\n            plotLineDetector.reDrawAll()\n            #~ pyplot.show()\n\n                    \n\n        return list_beta,list_gamma\n        \n    else: # if OpenElectrophy has not been properly imported\n\n        print '# ### Oscillation analysis not possible ####'\n        print '# ### OpenElectrophy 0.2 is required #######'\n        print\n        return [],[]\n        \nif __name__==\"__main__\":\n    \n    from scipy import *\n    a=0.001*rand(10000)\n    sr=1000.\n    \n    freq=25\n    a[3000:4000]+=cos(2*pi*freq*arange(1000)/sr)\n    freq=60\n    a[3500:4500]+=cos(2*pi*freq*arange(1000)/sr)\n    \n    beta_gamma_detection(a,sr,freq_cut=40,plot_fig=True,osc_th=0.6)\n    \n    pyplot.show()\n    \n    "
        ],
        "variables": [
            "of",
            "ind2_keep",
            "second",
            "Put",
            "Detect",
            "can",
            "neuralensemble",
            "in",
            "figure",
            "window",
            "between",
            "as",
            "verbose",
            "pyplot",
            "imported",
            "This",
            "same",
            "time_stop",
            "Failure",
            "want",
            "AnalogSignal",
            "coding",
            "has",
            "burn_time",
            "amplitude_max",
            "the",
            "freq_line",
            "oscillation",
            "osc_th",
            "or",
            "based",
            "OpenElectrophy_svn",
            "cut",
            "Successful",
            "f_test",
            "list_filter",
            "print",
            "reDrawAll",
            "Pxx",
            "script",
            "spectrum",
            "import",
            "else",
            "must",
            "type",
            "OE2",
            "two",
            "ind1",
            "__builtins__",
            "plotLineDetector",
            "Numpy",
            "computeAllStep",
            "value",
            "Second",
            "sr",
            "time",
            "provided",
            "minimum_cycle_number",
            "scipy",
            "any",
            "properly",
            "here",
            "format",
            "f_stop",
            "rand",
            "oe",
            "sampling_rate",
            "UI",
            "ind_beta",
            "utf",
            "detection",
            "assumed",
            "avoid",
            "Compute",
            "regroup_full_overlap",
            "inspect",
            "__version__",
            "pi",
            "elif",
            "and",
            "ind_osc1_keep",
            "lineDetector",
            "version",
            "clean",
            "freq_max",
            "recordings",
            "you",
            "slightly",
            "a",
            "pad_to",
            "ind_gamma",
            "if",
            "compare_osc",
            "osc2",
            "__main__",
            "cos",
            "Assume",
            "simultaneous",
            "std_relative_threshold",
            "__name__",
            "PlotLineDetector",
            "separation",
            "oscillations",
            "mlab",
            "freq_start",
            "freq_cut",
            "allows",
            "reference_zone",
            "set",
            "numpy",
            "anaSig",
            "max",
            "case",
            "then",
            "freqs",
            "scalogram",
            "useful",
            "sig_mask",
            "this",
            "matplotlib",
            "True",
            "xlim",
            "fig",
            "time_max",
            "assert",
            "try",
            "artificial",
            "ind1_keep",
            "Oscillation",
            "inf",
            "detected",
            "test_oe",
            "overlap",
            "detrend_mean",
            "trac",
            "filter",
            "parameters",
            "part",
            "required",
            "comp",
            "possible",
            "osci",
            "LFP",
            "LooseVersion",
            "Path",
            "mean",
            "latter",
            "float",
            "frequency",
            "global",
            "eliminate_simultaneous",
            "osc",
            "sig",
            "copy",
            "osc1",
            "http",
            "not",
            "both",
            "intersect1d",
            "checked",
            "time_line",
            "been",
            "on",
            "abs_threshold",
            "window_hanning",
            "home",
            "Fs",
            "manual_threshold",
            "path",
            "NFFTpoints",
            "psd",
            "None",
            "analysis",
            "from",
            "trunk",
            "recomp_osc_properties",
            "be",
            "back",
            "ind_max",
            "detect",
            "False",
            "spectrum_analysis",
            "beta_gamma_detection",
            "ind2",
            "In",
            "sys",
            "value_line",
            "list_gamma",
            "NFFT",
            "OpenElectrophy",
            "noverlap",
            "list",
            "beta",
            "LineDetector",
            "list_oscillation",
            "is",
            "which",
            "plot_fig",
            "detrend",
            "PLotLineDetecor",
            "detection_zone",
            "f_start",
            "r_",
            "in1d",
            "Osc_th",
            "oe_valid",
            "freq_stop",
            "all",
            "only",
            "org",
            "given",
            "abs",
            "for",
            "argmax",
            "show",
            "size",
            "time_start",
            "It",
            "def",
            "int",
            "by",
            "threshold",
            "to",
            "distutils",
            "freq",
            "return_full",
            "Bad",
            "arange",
            "burn",
            "nfourcau",
            "return",
            "used",
            "where",
            "signal",
            "downloaded",
            "gamma",
            "append",
            "shortens",
            "First",
            "were",
            "plotting",
            "close",
            "it",
            "eliminate_partial_overlap",
            "everything",
            "len",
            "setmember1d",
            "except",
            "Hz",
            "list_beta"
        ]
    },
    "readme.txt": {
        "comments": [
            "For any help, contact:\nNicolas Fourcaud-Trocm\u00e9: nicolas.fourcaud-trocme@cnrs.fr\nFran\u00e7ois David: francois.david5@free.fr\n\n############################################################\n\n* This model has been run with:\n\n    Python 2.6/2.7 (https://www.python.org/)\n    BRIAN 1.4.1 (http://briansimulator.org/)\n\n* Oscillation analysis and time-frequency plots are done with:\n\n    OpenElectrophy 0.2 (http://neuralensemble.org/trac/OpenElectrophy)\n\n    Note that if OpenElectrophy is not installed as a global module,\n    OpenElectrophy path can be provided in \"oscillation_analysis.py\" line 18\n\n###########################################################################\n\nFile details:\n\n* model_mitral_clean.py and model_granule_clean.py: \n    contain equations and some fixed parameters of mitral and granule cell models\n    Mitral cell model is issued from David et al. Plos Comp Biol (2009),\n    Granule cell model is a standard QIF model with f-I curve estimated based on Davison (2001, PhD Thesis)\n    \n* reseau_mitral_granule_fig_param_dic.py:\n    it's the main script to describe full network and launch network simulations. \n    It contains a dictionary of model parameters with all default values and comments on the role of most parameters. \n    The \"reseau_mitral_granule\" function run the network and return some recordings. It can be safely multiprocessed.\n    The \"main\" section (starting line 229) shows how to run either a single model or a set of models while varying one parameter.\n    Each model run can be configured by feeding a distinct dictionay of parameters \"param_dict\".\n    A set of dictionary parameters used in the article is given in \"params_for_article_fig.py\" and can be easily imported (see commented lines)\n    \n* oscillation_analysis.py, plot_single_run_from_file.py, plot_multi_run_from_file.py:\n    contains functions to analyse gamma/beta oscillations and plot output of network simulations \n    (either detailed output for single simulations, or simplified output as a function of the varied parameters for multiple simulations)\n    Note that simulation outputs can be saved in a file (see options in \"reseau_mitral_granule_fig_param_dic.py\") and \n    later plotted with \"plot_single_run_from_file.py\" or \"plot_multi_run_from_file.py\" (see their \"main\" sections).\n    If OpenElectrophy is not installed on the computer, timefrequency plots and oscillation analysis are skipped.\n    \n* populationstatemonitor.py: is a simple helper function derived from BRIAN simulator \"Statemonitor\"\n",
            ""
        ],
        "variables": [
            "of",
            "section",
            "simulation",
            "in",
            "briansimulator",
            "neuralensemble",
            "contact",
            "Python",
            "can",
            "estimated",
            "help",
            "reseau_mitral_granule_fig_param_dic",
            "Each",
            "installed",
            "david5",
            "as",
            "saved",
            "imported",
            "This",
            "has",
            "one",
            "Statemonitor",
            "details",
            "model_mitral_clean",
            "the",
            "trocme",
            "oscillation",
            "Fourcaud",
            "or",
            "based",
            "full",
            "analyse",
            "s",
            "simple",
            "For",
            "script",
            "with",
            "line",
            "some",
            "BRIAN",
            "see",
            "issued",
            "plots",
            "varied",
            "sections",
            "how",
            "dictionary",
            "time",
            "fr",
            "provided",
            "equations",
            "standard",
            "while",
            "helper",
            "any",
            "param_dict",
            "If",
            "simulations",
            "parameter",
            "File",
            "Comp",
            "either",
            "QIF",
            "feeding",
            "main",
            "https",
            "David",
            "et",
            "and",
            "recordings",
            "contains",
            "a",
            "reseau_mitral_granule",
            "if",
            "multiprocessed",
            "models",
            "The",
            "varying",
            "fourcaud",
            "al",
            "oscillations",
            "outputs",
            "distinct",
            "Nicolas",
            "that",
            "set",
            "describe",
            "options",
            "PhD",
            "detailed",
            "computer",
            "Oscillation",
            "Mitral",
            "output",
            "py",
            "trac",
            "mitral",
            "parameters",
            "lines",
            "cnrs",
            "launch",
            "multiple",
            "plotted",
            "skipped",
            "their",
            "Davison",
            "shows",
            "single",
            "frequency",
            "global",
            "params_for_article_fig",
            "file",
            "Plos",
            "http",
            "not",
            "function",
            "later",
            "done",
            "been",
            "on",
            "default",
            "model",
            "fixed",
            "plot_single_run_from_file",
            "path",
            "analysis",
            "from",
            "be",
            "Granule",
            "network",
            "Biol",
            "OpenElectrophy",
            "values",
            "beta",
            "A",
            "nicolas",
            "is",
            "safely",
            "are",
            "article",
            "populationstatemonitor",
            "derived",
            "curve",
            "functions",
            "francois",
            "run",
            "commented",
            "all",
            "most",
            "starting",
            "simulator",
            "timefrequency",
            "org",
            "given",
            "for",
            "comments",
            "python",
            "It",
            "by",
            "plot_multi_run_from_file",
            "to",
            "module",
            "f",
            "return",
            "easily",
            "role",
            "used",
            "simplified",
            "dictionay",
            "oscillation_analysis",
            "free",
            "gamma",
            "configured",
            "granule",
            "contain",
            "Note",
            "it",
            "cell",
            "plot",
            "www",
            "Thesis",
            "I",
            "model_granule_clean"
        ]
    },
    "populationstatemonitor.py": {
        "comments": [
            "# -*- coding: utf-8 -*-\nfrom brian import *\nimport types\n\nclass PopulationStateMonitor(StateMonitor):\n    \"\"\"\n    Adapted from the Brian standard StateMonitor, it records the population average of a given variable every timestep\n    \"\"\"\n    \n    def __init__(self,P,varname,clock=None,record=True,timestep=1,when='end'):\n        StateMonitor.__init__(self,P,varname,clock,record,timestep,when)\n        \n    def __call__(self):\n        '''\n        This function is called every time step.\n        '''\n        V=self.P.state_(self.varname)\n        self._mu+=V.mean()\n        self._sqr+=V.mean()*V.mean()\n        if self.record is not False and self.curtimestep==self.timestep:\n            i = self._recordstep\n            if self._values is None:\n                self._values = []\n                self._times = []\n            if type(self.record)!=types.BooleanType:\n                self._values.append(V[self.record].mean()) \n            elif self.record is True:\n                self._values.append((V.copy()).mean())\n            self._times.append(self.clock.t)\n            self._recordstep += 1\n        self.curtimestep-=1\n        if self.curtimestep==0: self.curtimestep=self.timestep\n        self.N+=1\n\n    def reinit(self):\n        self._values = []\n        self._times = []\n        ri = self.get_record_indices()\n        self._values_cache = zeros((1, 0))\n        self.N = 0\n        self._recordstep = 0\n        self._mu = zeros(len(self.P))\n        self._sqr = zeros(len(self.P))\n\n"
        ],
        "variables": [
            "of",
            "utf",
            "brian",
            "Brian",
            "get_record_indices",
            "step",
            "types",
            "every",
            "mean",
            "_recordstep",
            "elif",
            "and",
            "copy",
            "given",
            "This",
            "average",
            "_mu",
            "i",
            "zeros",
            "coding",
            "a",
            "not",
            "curtimestep",
            "if",
            "self",
            "function",
            "def",
            "__init__",
            "the",
            "_times",
            "__call__",
            "_sqr",
            "PopulationStateMonitor",
            "called",
            "state_",
            "None",
            "record",
            "from",
            "StateMonitor",
            "ri",
            "type",
            "_values_cache",
            "import",
            "False",
            "append",
            "end",
            "records",
            "timestep",
            "True",
            "Adapted",
            "population",
            "time",
            "_values",
            "clock",
            "standard",
            "class",
            "it",
            "BooleanType",
            "when",
            "reinit",
            "is",
            "len",
            "V",
            "P",
            "variable",
            "varname",
            "N",
            "t"
        ]
    }
}